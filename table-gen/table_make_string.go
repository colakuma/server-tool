package main

const (
	varName  = "map%s"
	mapType  = "%sMap map[%s]*%s\n\t"
	mapVar   = "%s atomic.Pointer[%sMap]\n\t"
	callLoad = "\tLoad%s()\n"
	keyMake  = `key := fmt.Sprintf("%s",%s)
	`
	keyMake2 = `key := tools.MakeKey%d(%s)
	`
	loadFunc = `
func Load%s() {
	tmp := make(%sMap)
	if !hot {
		initHotLoad("%s", Load%s)
		initHotLoad("%s", Load%s)
	}
	load("%s", "%s", &tmp)
	AfterLoad%s(&tmp)
}	
`
	loadAllFunc = `
func LoadAll() {
	hot = false
%s
	hot = true
	callAfterLoad(afterLoadCall)
	afterLoadCall = afterLoadCall[:0]
}	
`
	getFunc = `
func Get%s(%s) *%s {
	%sreturn (*%s.Load())[key]
}
`
	getAllFunc = `
func Get%sMap() *%sMap {
	return %s.Load()
}
`

	fileContext = `// Code generated by table-gen. DO NOT EDIT.

package gtable

import (
	"sync/atomic"

	"%s/tools"
)

type(
	%s)

var(
	hot bool
	%s)
%s
%s
%s
%s
%s	
`
)

const (
	varFile = `//+build tablegen
	
package gtable
var(
	%s
)

func init(){
	%s
}
`
)

const (
	customFile = `// Code generated by table-gen. DO NOT EDIT.

package gtable

import (
	"sync/atomic"
)

type(
	%s
)
var(
	DummyData     atomic.Value
	%s
)

%s
`
)

const (
	afterFunc = `func AfterLoad%s(m *%sMap) {%s
%s
	for %s, v := range *m {
%s}
	%s
	appendAfterLoad(func() {
		%s.Store(m)
%s
	})
}
`
	afterFunc2 = `func AfterLoad%s(m *%sMap) {%s
	appendAfterLoad(func() {
		%s.Store(m)
	})
}
`
	getCustomFunc = `func Get%s() %s {
	if slice := %s.Load(); slice != nil {
		return *slice
	}
	return nil
}

`
	structAfterLoad = `
	((*%s)(nil)).afterLoad(*m)`
	afterMake = "\t%s := make(%s, 0)"
	afterOp   = `		if v.%s(%d) {
			%s = append(%s, %s)
		}
	`
	afterSort  = "((*%s)(nil)).%sSort(%s,%d)"
	afterOpMap = `		if v.%s(%d) {
			%s[k]=v
		}
`
	afterAppend = "\t\t%s.Store(&%s)"
)

const (
	getKeyStringPattern = `func (p *%s) GetKey() any {
	return fmt.Sprintf("%s", %s)
}
`
	getKeyNPattern = `func (p *%s) GetKey() any {
	return tools.MakeKey%d(%s)
}
`
	getKeyPattern = `func (p *%s) GetKey() any {
	return p.%s
}
`
)
